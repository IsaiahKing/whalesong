What is Whalesong?

    Whalesong is a compiler from Racket bytecode to JavaScript.


Why would anyone care?

    * Because it allows Racket programs to be deployed on the web.

    * Furthermore, Racket programs can access native JavaScript APIs.

    * Because my previous attempt at this produced a slower evaluator;
    this is much faster.


What do you want to show?

    I want to show the tool in action, programs that use it
       - like World programming, FFI

    I want to show performance numbers (which means benchmarks...)

    I also want to show some of the internals, to show why the
    JavaScript context makes things more complicated.


How do you use it?

    I have a command line tool that consumes Racket programs and
    produces standalone JavaScript applications.

    I'll be using this as the underlying evaluator for WeScheme

       Why?  Performance.


What were the technical advantages of your approach?

    Reusing the Racket compiler.  Strong possibility of reusing most
    of the Racket standard library, as soon as we can bootstrap
    racket/base.

What were some of the technical challenges?

    Supporting the features of the Racket virtual machine (tail calls,
    continuations)


What needs to be done next?

    Adding enough primitives to run racket/base


----------------------------------------------------------------------


The story for the presentation:

What's Whalesong?  It's a Racket to JavaScript compiler.  Here's an
example of it in action.

(Compile a very simple program to a web page, a computation, then show
that it's effective.)


Whalesong will be used to support World programming for the web.  For
example, we can support simple animations, as you'd expect:

(Show a world program: the falling rain drops program.)



But we can also do programs that have interactivity, such as:

(Show another world program: pacman.)



A core idea behind Whalesong is to reuse Racket's infrastructure as
much as possible.  I'm not a compiler person.  I can piggiback on
Matthew's work, though.  Whalesong reuses the bytecode compiler, and
translates the bytecode to JavaScript.  I really am reusing the
linguistic features of Racket.  For example, let's look at the
less-than-impressive program output below.

(Show the hello world program)


This is not too impressive.  But let's look at the source code.

(Show the BF program.)


Yeah.  So we really are using Racket's underlying language features to
handle things like macro expansion.



Because we're on the web, we may even want to use functions that we've
written in Racket as a part of regular web pages.  Whalesong lets you
do this.

(Show the factorial example, and how it can be used by external
JavaScript on a web page).



There's quite a bit that's missing: we don't yet have all of the
primitives necessary to compile racket/base, so all Whalesong programs
have to be in a language that ultimately bottoms to (planet
dyoo/whalesong/lang/base).

I'm going to get a release out in the following month, and the new
versions of Moby Scheme for Smartphones, as well as the WeScheme
environment, will be using the underlying evaluator of Whalesong.



If you're interested, please talk to me during the break.  Thanks!
